
# 主提示符（>>>）
# 次提示符（...）

# 输出
print "Hello, World!"

# 算术运算求绝对值
abs(-4)

# 定义字符串变量并输出
myString = "Hello Python"
print myString

# 单引号和双引号内字符串一样
"""
注意:在仅用变量名时，输出的字符串是被用单引号括起来了的。这是为了让非字符串对 象也能以字符串的方式显示在屏幕上--即它显示的是该对象的字符串表示，而不仅仅是字符 串本身。
引号表示你刚刚输入的变量的值是一个字符串。等你对 Python 有了较深入的了解之后， 你就知道 print 语句调用 str()函数显示对象，而交互式解释器则调用 repr()函数来显示对象。
"""

# 下划线(_)在解释器中有特别的含义，表示最后一个表达式的值。

"""
%s 表示由一个字符串来替换，而%d 表示由一个整数来替换，另外一个很常用的就是%f， 它 表示由一个浮点数来替换。
Print 语句也支持将输出重定向到文件。这个特性是从 Python2.0 开始新增的。符号 >> 用来重定向输出，下面这个例子将输出重定向到标准错误输
出:

"""
print "%s is Number %d!" % ("Python", 1)

# 从用户那里得到数据输入的最容易的方法是使用 raw_input()内建函数。它读取标准输入，并将读取到的数据赋值给指定的变量。
user = raw_input("Enter login name:")

'''
从用户那里得到数据输入的最容易的方法是使用 raw_input()内建函数。它读取标准输入，
并将读取到的数据赋值给指定的变量。 你可以使用 int() 内建函数将用户输入的字符串转换 为整数。
'''

"""
    >>> num = raw_input('Now enter a number: ')
    Now enter a number: 1024
    >>> print 'Doubling your number: %d' % (int(num) * 2)
    Doubling your number: 2048
"""

# 从标准输入读取一个字符串并自动删除串尾的换行字符。

"""
将函数分为两大类，一类只做事，不 需要返回值(比如与用户交互或设置变量的值)， 另一类则执行一些运算，最后返回结果。
如 果输出就是函数的目的，那么在函数体内使用 print 语句也是可以接受的选择。
"""

# Python 有两种除法运算符，单斜杠用作传统除法， 双斜杠用作浮点除法(对结果进行四舍五入)。
# 传统除法是指如果两个操作数都是整数的话， 它将执行是地板除(取比商小的最大整数)
# 而浮 点除法是真正的除法，不管操作数是什么类型，浮点除法总是执行真正的除法。
# 还有一个乘方运算符， 双星号(**)。 3**4(3的4次方)
# +(加法) -（减法） *（乘法） /（传统除法） //（浮点除法） %（取余运算） **（乘方运算） -2*4+3**2

"""
+ 和 - 优先级最低， *, /, //， % 优先级较高， 单目运算符 + 和 - 优先级更高， 乘方的优先级最高。(3 ** 2) 首先求值， 然 后是 (-2 * 4)， 然后是对两个结果进行求和。
"""

# 比较运算符
# < <= > >= == != <>
# Python 目前支持两种“不等于”比较运算符， != 和 <> ， 分别是 C 风格和 ABC/Pascal 风格。目前后者慢慢地被淘汰了，

# 逻辑运算符 and or not

"""
核心风格: 合理使用括号增强代码的可读性，在很多场合使用括号都是一个好主意，而没 用括号的话，会使程序得到错误结果，或使代码可读性降低，引起阅读者困惑。。
括号在 Python 语言中不是必须存在的， 不过为了可读性， 使用括号总是值得的。
"""

"""
# 变量和赋值
# Python 中变量名规则与其它大多数高级语言一样， 都是受 C 语言影响(或者说这门语言 本身就是 C 语言写成的)。
# 变量名仅仅是一些字母开头的标识符--所谓字母开头--意指大
# 写或小写字母，另外还包括下划线( _ ). 其它的字符可以是数字，字母， 或下划线。
# Python 变量名是大小写敏感的， 也就是说变量 "cAsE" 与 "CaSe" 是两个不同的变量。

# Python 是动态类型语言， 也就是说不需要预先声明变量的类型。 变量的类型和值在赋值 那一刻被初始化。变量赋值通过等号来执行。

"""

# 算术运算
"""
n = n * 10 <===> n*=10

Python 不支持 C 语言中的自增 1 和自减 1 运算符， 这是因为 + 和 - 也是单目运算符， Python 会将 --n 解释为-(-n) 从而得到 n , 同样 ++n 的结果也是 n.
"""

# 数字
"""
Python 支持五中基本数字类型，其中有三种是整形
  int (有符号整数)
  long (长整数)   
  bool (布尔值)
  float (浮点值)   
  complex (复数)
"""

"""
Python 中有两种有趣的类型是 Python 的长整型和复数类型。
Python 的长整数所能表达的范围远远超过 C 语言的长整数， 事实上， Python 长整数仅受限于用户计算机的虚拟内存总数。
从 Python2.3 开始，再也不会 报整型溢出错误， 结果会自动的被转换为长整数。在未来版本的 Python 中， 两种整数类型将 会无缝结合， 长整数后缀 “L”也会变得可有可无。

布尔值是特殊的整数。 尽管布尔值由常量 True 和 False 来表示， 如果将布尔值放到一 个数值上下文环境中(比方将 True 与一个数字相加)， True 会被当成整数值 1， 而 False 则会被当成整数值 0。
复数(包括-1 的平方根, 即所谓的虚数)在其它语言中通常不被直接 支持(一般通过类来实现)。

# 其实还有第六种数字类型， decimal， 用于十进制浮点数。不过它并不是内建类型， 你 必须先导入 decimal 模块才可以使用这种数值类型。 
由于在二进制表示中有一个无限循环片段，数字 1.1 无法用二进制浮 点数精确表示。因此， 数字 1.1 实际上会被表示成:
    >>> 1.1
    1.1000000000000001
    >>> print decimal.Decimal('1.1')
    1.1

"""

# 字符串
"""
# Python 中字符串被定义为引号之间的字符集合。

Python 支持使用成对的单引号或双引号， 三引号(三个连续的单引号或者双引号)可以用来包含特殊字符。
使用索引运算符( [ ] )和切 片运算符( [ : ] )可以得到子字符串。
字符串有其特有的索引规则:第一个字符的索引是 0， 最后一个字符的索引是 -1

加号( + )用于字符串连接运算，星号( * )则用于字符串重复。
    >>> print 'Hello'+'World!'
    HelloWorld!
    >>> print 'Hello'*4
    HelloHelloHelloHello

"""

# 列表和元组
"""
可以将列表和元组当成普通的“数组”，它能保存任意数量任意类型的 Python 对象。
和数 组一样，通过从 0 开始的数字索引访问元素，但是列表和元组可以存储不同类型的对象。

列表和元组有几处重要的区别。
列表元素用中括号( [ ])包裹，元素的个数及元素的值可 以改变。
元组元素用小括号(( ))包裹，不可以更改(尽管他们的内容可以)。
元组可以看成是 只读的列表。通过切片运算( [ ] 和 [ : ] )可以得到子集，这一点与字符串的使用方法一样。
    
    >>> pystr = 'Python!'
    >>> pystr[1]
    'y'
    >>> pystr[2:5]  # 从index=2 到 index=5
    'tho' 
    >>> pystr[:2]   # index=2 之前的
    >>> pystr[2:]   # index=2 之后的
    
元组也可以进行切片运算，得到的结果也是元组(不能被修改):
    >>> aTuple = ('robots', 77, 93, 'try')
    >>> aTuple
    ('robots', 77, 93, 'try')
字典是 Python 中的映射数据类型，工作原理类似 Perl 中的关联数组或者哈希表，由键- 值(key-value)对构
    >>> aTuple[:3]
    ('robots', 77, 93)
    >>> aTuplep[1]
        Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        NameError: name 'aTuplep' is not defined
    >>> aTuple[1]
    77

"""

# 字典
"""成。
几乎所有类型的 Python 对象都可以用作键，不过一般还是以数字或者 字符串最为常用。
值可以是任意类型的 Python 对象，字典元素用大括号({ })包裹。

    >>> aDict = {'host': 'earth'} 
    >>> aDict['port'] = 80 # add to dict
    >>> aDict
    {'host': 'earth', 'port': 80}
    >>> aDict['host']
    'earth'   

"""

# if 语句
"""
Python 与其它语言不同， 条件条达式并不需要用括号括起来

"""

# While 循环语句

# for 循环和 range()内建函数
"""
    >>> foo = 'abc'
    >>> for c in foo:
    ...     print c     # 加 tab 键
    ... 
    a
    b
    c

    >>> squared = [x ** 2 for x in range(4)]
    >>> for i in squared:
    ...     print i
    ... 
    0
    1
    4
    9   

"""

# 文件和内建函数 open(),file()
"""
handle = open(file_name, access_mode = 'r')
file_name 变量包含我们希望打开的文件的字符串名字，access_mode 中 'r' 表示读取， 'w' 表示写入， 'a' 表示添加。
其它可能用到的标声还有 '+' 表示读写， 'b'表示二进制访 问. 
如果未提供 access_mode ， 默认值为 'r'。如果 open() 成功， 一个文件对象句柄会被 返回。所有后续的文件操作都必须通过此文件句柄进行。
当一个文件对象返回之后， 我们就可 以访问它的一些方法， 比如 readlines() 和 close().文件对象的方法属性也必须通过句点属 性标识法访问

属性是与数据有关的项目， 属性可以是简单的数据值， 也可以是可执行对象， 比如函数 和方法。

我如何访问对象属性? 使用句点属性标识法。 也就是说在对象名和属性名之间加一个句 点: object.attribute

    # 
    filename = raw_input('Enter file name: ')
    fobj = open(filename, 'r')
    for eachLine in fobj:
    print eachLine,
    fobj.close()

我们的代码没有用循环一次取一行显示， 而是做了点改变。我们一次读入文件的所有行， 然后关闭文件， 再迭代每一行输出。
这样写代码的好处是能够快速完整的访问文件。内容输出 和文件访问不必交替进行。这样代码更清晰， 而且将不相关的任务区分开来。
需要注意的一点是文件的大小。 上面的代码适用于文件大小适中的文件。对于很大的文件来说， 上面的代码 会占用太多的内存， 这时你最好一次读一行。

file()内建函数是最近才添加到 Python 当中的。它的功能等同于 open()， 不过 file() 这个名字可以更确切的表明它是一个工厂函数。(生成文件对象)类似 int()生成整数对象，
dict()生成字典对象。

"""

# 错误和异常
"""
编译时会检查语法错误，不过 Python 也允许在程序运行时检测错误。当检测到一个错误， Python 解释器就引发一个异常， 并显示异常的详细信息。
要给你的代码添加错误检测及异常处理， 只要将它们封装在 try-except 语句当中。 try 之后的代码组， 就是你打算管理的代码。 except 之后的代码组， 则是你处理错误的代码。

"""

# 函数
"""
Python 中的函数使用小括号( () )调用，函数在调用之前必须先定义。 如果函数中没有 return 语句， 就会自动返回 None 对象。
Python 是通过引用调用的。 这意味着函数内对参数的改变会影响到原始对象。不过事实 上只有可变对象会受此影响， 对不可变对象来说， 它的行为类似按值调用。

定义一个函数的语法由 def 关键字及紧随其后的函数名再加上该函数需要的几个参数组 成。
函数参数(比较上面例子中的 arguments)是可选的， 这也是为什么把它们放到中括号中 的原因。
(在你的代码里千万别写上中括号!)这个语句由一个冒号(:)结束(与 if 和 while 语句的结束方式一样)， 之后是代表函数体的代码组

    >>> def addMe2Me(x):    
    ...     'apply+operation to argument'
    ...     return (x+x)
    ... 
    >>> addMe2Me(4.25)
    8.5
    >>> addMe2Me([-1,'abc'])
    [-1, 'abc', -1, 'abc']
    
"""

# 类
"""
    Python 并不强调以面向对象的方式编程；
    如何定义类：
    >>> class ClassName(base_class[es]):
    ...     "optional documentation string"
    ...     static_member_declarations
    ...     method_declarations

    使用 Class 关键词定义类。可以提供一个可选的父类或者说基类；如果没有合适的基类，就使用object 作为基类、Class 行之后是可选的文档字符串，静态成员定义，及方法定义。
    
    class FooClass(object):
        \"""my very first class: FooClass\"""
        version = 0.1 # class (data) attribute
        def __init__(self, nm='John Doe'):
        \"""constructor\"""
        self.name = nm # class instance (data) attribute print 'Created a class instance for', nm
        def showname(self):
        \"""display instance attribute and class name\""" print 'Your name is', self.name
        print 'My name is', self.__class__.__name__
        def showver(self):
        \"""display class(static) attribute\"""
        print self.version # references FooClass.version def addMe2Me(self, x): # does not use 'self' \"""apply + operation to argument\"""
        return x + x

        # 在上面这个类中，我们定义了一个静态变量 version, 它将被所有实例及四个方法共享， __init__()， showname(), showver(), 及熟悉的 addMe2Me().
        # 这些 show*()方法并没有做什 么有用的事情， 仅仅输出对应的信息。 __init__() 方法有一个特殊名字， 所有名字开始和 结束都有两个下划线的方法都是特殊方法。
        # 当一个类实例被创建时， __init__() 方法会自动执行， 在类实例创建完毕后执行， 类 似构建函数。__init__() 可以被当成构建函数， 不过不象其它语言中的构建函数， 它并不创 建实例--它仅仅是你的对象创建后执行的第一个方法。
        # 它的目的是执行一些该对象的必要的初 始化工作。通过创建自己的 __init__() 方法， 你可以覆盖默认的 __init__()方法(默认的 方法什么也不做)，从而能够修饰刚刚创建的对象。在这个例子里，我们初始化了一个名为 name 的类实例属性(或者说成员)。
        # 这个变量仅在类实例中存在， 它并不是实际类本身的一部分。 __init__()需要一个默认的参数， 前一节中曾经介绍过。毫无疑问，你也注意到每个方法都有 的一个参数， self.
    
"""

# 如何创建类实例
"""
    >>> foo1 = FooClass()
     Created a class instance for John Doe
     当一个实例被创建， __init__()就会被自动调用。不管这个__int__()是自定义的还是默认的。
     创建一个类实例就像调用一个函数， 它们确实拥有一样的语法。它们都是可调用对象。类 实例使用同样的函数运算符调用一个函数或方法。既然我们成功创建了第一个类实例， 那现在 来进行一些方法调用:
     
"""

























